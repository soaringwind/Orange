# 图像处理

## 1. 基础知识

## 2. 细节特征

## 3. 局部特征

如果仅有边缘信息，很多图像操作都无法进行，如全景拼接，因此需要对图像的一些局部特征进行检测。

全景拼接步骤：

1. 提取特征。
2. 特征匹配。
3. 特征对齐。

优秀的特征特点：

1. 可重复性
2. 有意义
3. 提取高效
4. 局部性

### 3.1 Harris角点

角点：图像中二维或者三维的角点，它同时具有重复性及独特性。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220415151502424.png" alt="image-20220415151502424" style="zoom:50%;" />

上面两张图，尽管发生了光照变化，旋转，但是角点的检测基本是一致的，可以看出角点是具有可重复性，利用角点可以对两张图像进行拼合。

之前进行过边缘检测，角点与边缘和正常区域的区别如下：

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220415152102098.png" alt="image-20220415152102098" style="zoom:50%;" />

这里看出，正常区域、边缘和角点的区别在于，在一个窗口区域，正常区域在每一个方向都没有很大的变化；边缘区域则在径向方向有较大的变化；角点区域则在每一个方向都有很大的变化。因此使用一个窗口区域的函数对该区域进行检测。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220415153404805.png" alt="image-20220415153404805" style="zoom:50%;" />

```
w(x, y): 指的是窗口函数，往往使用高斯函数。
I(x, y): 指的是图像上的每一点。
E(u, v): 指的是计算之后的每一点，尺寸和原图一样。
```

为了方便计算，在(0, 0)对其进行二阶泰勒展开，化简得到：

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220415154157292.png" alt="image-20220415154157292" style="zoom:50%;" />

```
Iy = 0 -> E(u, v) = u**2 * Ix**2 即只与x方向有关。
```

也就是说当M（二维矩阵）的某一个特征值为0的时候，表示的是边缘特征。

实际上M为实对称矩阵，在空间的坐标中表示的是椭圆（经过旋转），如果解出其特征值，也就是通过正交矩阵对其进行旋转，则可以得到标准椭圆。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220415155353546.png" alt="image-20220415155353546" style="zoom:50%;" />

通过对lam1和lam2两个特征值的判断，可以确定其在不同方向的变化趋势。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220415155721123.png" alt="image-20220415155721123" style="zoom:50%;" />

但是同时判断lam1和lam2过于麻烦，因此一般使用简化公式。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220415155821441.png" alt="image-20220415155821441" style="zoom:50%;" />

以上就是Harris角点检测的原理，下面展示Harris角点的检测步骤。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220415160640013.png" alt="image-20220415160640013" style="zoom:50%;" />

### 3.2 SIFT特征点检测

之前特征大部分都是点的信息，对于图片的理解还是过于简单，当在做图像识别或者拼接时，更多时候需要区域性的特征，拉普拉斯算子（高斯函数二阶导）则可以用来检测图像区域性的特征。

#### 3.2.1 LOG(拉普拉斯算子)

在前面的边缘提取中，我们使用高斯函数一阶导可以找到边缘（即边缘处会得到最大值），而实际上使用高斯函数二阶导也可以确定边缘（即0点）。拉普拉斯算子指的就是高斯二阶导，而当拉普拉斯算子的sigma与区域半径相同时，会得到区域的最大值。也就是说，如果想要检测某一个半径的区域，只需要拿同样大小的sigma的拉普拉斯算子进行卷积即可得到最大的响应值。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220511195536702.png" alt="image-20220511195536702" style="zoom:50%;" />

这提供了一个检测区域半径的办法，也就是通过改变sigma的值来检测是否正好获得最大响应值，如果获得最大响应值就可以得到对应的半径。然而，随着sigma的增加，对信号进行卷积会导致信号衰减，无法准确找到最大响应值，所以需要对拉普拉斯算子进行尺度归一化（也就是将sigma带来的面积影响消除）。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220511221635630.png" alt="image-20220511221635630" style="zoom:50%;" />

一阶拉普拉斯sigma=半径，而二阶拉普拉斯算子sigma=半径/根号2。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220511223117265.png" alt="image-20220511223117265" style="zoom:50%;" />

对同一个图像使用多个sigma的拉普拉斯算子进行卷积，并在连续的sigma中找到最大响应值，这样就可以确定出一个区域的半径，但是随着sigma的增加，会带来一系列的问题，比如模板较大，且运算时间会加长。尤其麻烦的是，如果区域半径很大，那么就需要一个很大的sigma来进行运算。这个方法被称为LOG方法，在实际过程中，如果想要应用的话，需要结合harris角点，先拿到感兴趣的点，再对感兴趣的点进行LOG运算，来确定感兴趣的区域。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220511225201072.png" alt="image-20220511225201072" style="zoom:50%;" />

#### 3.2.2 DOG

在前面介绍了二阶的拉普拉斯算子可以找到感兴趣的区域，但是有一个缺点，也就是会带来巨大的运算量。DOG（difference of guassians）也就是高斯差分法，通过两个高斯函数的卷积差来代替拉普拉斯卷积的结果，两个函数的图像如下，可以看到是非常的相近的，因此可以进行替代。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220512001226827.png" alt="image-20220512001226827" style="zoom:50%;" />

有了DOG的方法，就可以提高斑点检测的效率，因为可以直接对原图进行高斯卷积，之后两张图像相减得到LOG图像。之后，为了进一步提高效率，在原图基础上，通过降采样的方式，来使图像减小一倍，也就是让斑点区域半径减小一倍。这样相同的sigma，则可以检测出更大的区域，之前提到sigma越大，效率越低，这里通过降采样的方式来进一步提高效率。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220512004231897.png" alt="image-20220512004231897" style="zoom:50%;" />

对每一层的DOG图像进行极大值检测及非极大值抑制，原理和之前的LOG一样，取上中下三幅图，找出极大值，将其在原图的位置以及检测的区域半径（即sigma）记录下来。这样也就获取了图像SIFT的特征点信息，但仅仅获取点的信息还不够，需要进一步获取点对应的区域信息。

首先，对特征点所在的区域进行主方向的确定，通过划定r=1.5*sigma的区域，同时对0-360度每10度为一个范围进行梯度统计，获得区域的梯度方向直方图，如下图。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220512235949841.png" alt="image-20220512235949841" style="zoom:50%;" />

确定了区域的主方向之后，我们在对比两张图时就可以旋转到主方向来对比，这也就有了旋转不变性。但是仅有方向还不够，还需要有区域的细节特征。接下来需要对每一个SIFT特征点，生成一个唯一的SIFT特征描述符，以便其后续与其他图片比较。一个SIFT特征描述符由一个128维的梯度方向直方图来确定。在得到了SIFT特征点的区域主方向之后，将一定范围内的点全部旋转至主方向后，跟之前一样计算0-360度的梯度方向直方图，只不过这次是分成8个格子，每45度为一格，如下图。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220513001304561.png" alt="image-20220513001304561" style="zoom:50%;" />

只要能够取到128维的向量出来即可，当然有更准确的取法。这一步做完之后，SIFT特征描述符也就都能够生成，整张图象的SIFT特征也提取完毕。实际上，这里的算法是非常的复杂，因为想要准确的计算每一个值，也就需要泰勒展开，三线性插值等等方法，但即使没有使用这些准确算法，也同样可以提取到一些准确的SIFT特征。

最后，得到两张图像的SIFT特征描述符，之后直接暴力匹配即可，计算每一个特征描述符的欧式距离，找出最近的即可。

#### 3.2.3 HOG（梯度直方图）

从SIFT特征开始，到后面经常用到梯度直方图，实际上就是一种描述方向和梯度的方法。在一定区域内，通过计算该区域的x和y方向的梯度，计算出该区域方向，再以梯度为值，加到对应方向中作为值，以此构建出方向梯度直方图。

### 3.3 纹理表示

图片纹理：指的就是在图片中反复出现的某些内容，比如墙上的砖。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220531222712813.png" alt="image-20220531222712813" style="zoom:50%;" />

其实纹理就是一种模式或者说是一种模板，因此纹理检测也就可以变成一种模式识别。根据之前的卷积内容，如果使用特定的卷积模板，就可以检测出图像不同的特征。

在之前使用过高斯一阶导来检测x和y两个方向的边缘，这里如果将某个区域两个边缘的信息提取出来也可以作为纹理识别的一种。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220531230045198.png" alt="image-20220531230045198" style="zoom:50%;" />

用一个区域的x和y方向边缘的均值来作为该区域的纹理特征，之后对一张图像多个区域进行聚类，就可以将一张图像中不同的纹理特征进行区域。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220531231430398.png" alt="image-20220531231430398" style="zoom:50%;" />

但是这个方法有一个问题，就是需要提前设置好区域的大小，如果区域设置的不合适，可能无法得到较好的结果，因此需要尝试多个区域，如果区域大小变化对分类的结果差别不大的话，说明这个区域比较合适。

#### 3.3.1 滤波器组

之前的方法提取的特征太少，比如没有点的信息，没有局部区域的信息，因此使用一个滤波器组来提取图像的多个信息。比如典型的Gabor滤波器组，以及LM滤波器组，通过48个滤波器对一张图像进行卷积，之后将卷积的结果，进行平均，就可以得到一张图像的48维特征。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220531234450659.png" alt="image-20220531234450659" style="zoom:50%;" />

还有一类典型的协方差矩阵。

<img src="C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220531234639183.png" alt="image-20220531234639183" style="zoom:50%;" />

纹理识别最后还是可以结合HOG，将值和不同特征的滤波器进行结合，得到特征向量，根据向量的相似性来判断，该图像的特征。

## 4. 目标检测

目标检测的任务是要将一幅图中感兴趣的内容给找出来，最常见的就是人脸检测，常用的方法有adaboost+haar特征以及RCNN。

### 4.1 adaboost+haar特征

adaboost是一种机器学习方法，在这里不进行展开说明。主要介绍haar特征，haart特征实际上和之前介绍的纹理表示很像，同样是通过人为固定的模板来提取出人脸的共有信息，以此来区分人脸与非人脸。

论文中使用了四种模板，如下图：

![这里写图片描述](https://img-blog.csdn.net/20160816165648862)

和之前纹理表示类似，同样是将这四个模板进行一定的缩放来对一张图进行卷积操作，也就是用白色区域减去黑色区域得到一个值，将其存起来，最后把一张图像表示为一个向量。为了向量维度统一，因此图像的尺寸也要相同，通常为20或者24。为了提高效率，提出了一种积分图的做法，把卷积操作改变成了常数次的查询操作。即通过查询一个区域四个角的值来得到该区域的值，积分图如下图：

![这里写图片描述](https://img-blog.csdn.net/20160816173718135)

在实际做的过程中，如果提取完全的haar特征时间过长，一般会对haar特征的步长进行一定程度的限制，可以降低计算的时间，这个也会带来一定损失，看是否可以接受。

提取完haar特征之后，接下来就是做adaboost的过程，这里又提出了一种新的思路，通过级联多个adaboost强分类器，来达到一个极低的FP率，并且可以极快的提高检测的效率。思路如下，首先只训练一个简单的只包含少量特征的分类器，该分类器过滤一部分F样本，之后训练多个类似的分类器，越往后的分类器，包含的特征越多，也越复杂，但FP的比率很低。这样做的好处，不仅训练的时间减少，同时还能够在开始就删去很多明显不是人脸的区域来提高检测效率。

# 任务目标

1. 识别硬币的边缘
2. 通过RANSC拟合出硬币的半径，最终使用的是霍夫变换。
## 解决步骤
1. 读取图片
1.1 img = plt.imread("figure.jpg")
1.2 将三维变成一维数据，方便处理，可采用全部三维数据平均或者加权平均。
2. 边缘检测（canny算法）
2.1 高斯模糊：使用高斯模板去除一些异常点。
2.2 边缘检测：使用prewitt模板来卷积得到边缘。
    注意：这里的卷积使用的是对应元素点乘，而不是矩阵乘法，尽管矩阵乘法也OK。
2.3 非极大值抑制：缩小边缘特征，根据每个点的梯度方向进行抑制。
    注意：两种方法，第一，直接划分八个区域，将梯度方向简化。第二，线性插值，使用tan比值计算。
2.4 简化边缘：使用双阈值的办法，删除弱边缘。
    注意：使用深度搜索查询算法。并且使用集合来提高查询效率。
3. 拟合硬币的半径（霍夫变换）
3.1 边缘梯度：对简化边缘之后的二值图使用sobel算子进行x和y两个梯度方向的检测，确定x和y两个方向的梯度强度。
    注意：这里最好使用简化边缘之后的二值图，另外将x和y两个方向的梯度强度分别储存，方便后续投票确定圆心。
3.2 确定圆心：canny算法确定之后的边缘图，对每一个边缘点进行检测，每个点都会从x和y方向上进行投票。最终留下投票数较多的圆心。
    注意：由于很多点的边缘梯度其实并不完全统一，这里可以使用高斯滤波来进行平滑，需要注意两个圆心距离过近的话，认为是同一个圆，从而进行极大值抑制。
3.3 确定半径：根据之前筛选出来的圆心坐标，遍历简化边缘图上的边缘点，计算到圆心的距离，给半径投票。
    注意：不需要遍历所有点，只需要遍历最大半径范围内的点。
## Notes
1. numpy
2. matplotlib

# Harris角点检测
光拿到边缘的信息还不够，如果想要拼合图像等操作，则必须要将图中更有信息的点给提取出来。
特征点：

    1. 可重复性。
    2. 有意义。	
    3. 提取高效。
    4. 局部区域。

角点：图像中二维或者三维的交点。
![title](https://img-blog.csdn.net/20131123223210125)
计算Harris角点矩阵：
![title](https://img-blog.csdn.net/20131123223426734)
通过泰勒展开简化Harris矩阵公式：

![image-20220405230229563](C:\Users\weitao\AppData\Roaming\Typora\typora-user-images\image-20220405230229563.png)

![title](https://img-blog.csdn.net/20131123223447015)
M为实对称矩阵，需要通过R正交矩阵来将其转换为对角线矩阵。之后，通过经验公式计算Harris角点响应值：
![title](https://img-blog.csdn.net/20131123223742640)，其中k为0.04-0.06之间。

## 步骤
1. 计算x和y方向梯度
   梯度算子：sobel算子。
2. 计算二阶矩矩阵的特征值
   根据之前计算出来的x和y方向梯度，计算二阶矩矩阵，之后计算特征值。
3. 计算R值
   通过特征值计算R值。
4. 非极大值抑制
   根据之前计算的R值，在九宫格内进行非极大值抑制，并进行门限值过滤。
5. 展现
   将角点表现在原图上。